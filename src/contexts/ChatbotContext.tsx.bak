'use client'

import React, { createContext, useContext, useReducer, useCallback, useEffect } from 'react'
import { 
  ChatbotState, 
  ChatbotContextType, 
  Message, 
  CheckoutState, 
  ShippingInfo, 
  PaymentMethod,
  ConversationContext,
  QuickActionItem
} from '@/types/chatbot'
import { sendChatMessage } from '@/services/chatbotService'
import { useCart } from './CartContext'
import { CartItem } from '@/types'

const generateSessionId = (): string => {
  return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
}

// Improved message ID generation to ensure uniqueness and prevent collisions
let messageIdCounter = 0
const generateMessageId = (): string => {
  messageIdCounter += 1
  return `msg_${Date.now()}_${messageIdCounter}_${Math.random().toString(36).substr(2, 9)}`
}

const initialState: ChatbotState = {
  messages: [
    {
      id: '1',
      content: 'ì•ˆë…•í•˜ì„¸ìš”! C4pangì…ë‹ˆë‹¤. ğŸŒ¸\nì–´ë–¤ í–¥ìˆ˜ë¥¼ ì°¾ê³  ê³„ì‹ ê°€ìš”? ì·¨í–¥ì— ë§ëŠ” í–¥ìˆ˜ë¥¼ ì¶”ì²œí•´ë“œë¦´ê²Œìš”!',
      sender: 'bot',
      timestamp: new Date(),
      type: 'text'
    }
  ],
  isOpen: false,
  isTyping: false,
  isLoading: false,
  conversationContext: {
    sessionId: generateSessionId(),
    preferences: {
      fragranceTypes: [],
      priceRange: { min: 0, max: 300000 },
      favoriteNotes: [],
      preferredBrands: [],
      occasions: [],
      intensity: 'medium',
      purchaseHistory: [],
      viewHistory: [],
      cartHistory: []
    },
    recentProducts: [],
    purchaseHistory: []
  },
  checkoutState: null
}

type ChatbotAction =
  | { type: 'TOGGLE_CHATBOT' }
  | { type: 'ADD_MESSAGE'; payload: Message }
  | { type: 'SET_TYPING'; payload: boolean }
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'CLEAR_MESSAGES' }
  | { type: 'UPDATE_CONVERSATION_CONTEXT'; payload: Partial<ConversationContext> }
  | { type: 'START_CHECKOUT'; payload: { mode: 'cart' | 'direct'; items: CartItem[] } }
  | { type: 'UPDATE_CHECKOUT_STEP'; payload: CheckoutState['step'] }
  | { type: 'SET_SHIPPING_INFO'; payload: ShippingInfo }
  | { type: 'SET_PAYMENT_METHOD'; payload: PaymentMethod }
  | { type: 'CANCEL_CHECKOUT' }
  | { type: 'COMPLETE_CHECKOUT' }

const chatbotReducer = (state: ChatbotState, action: ChatbotAction): ChatbotState => {
  switch (action.type) {
    case 'TOGGLE_CHATBOT':
      return { ...state, isOpen: !state.isOpen }
    case 'ADD_MESSAGE':
      return { ...state, messages: [...state.messages, action.payload] }
    case 'SET_TYPING':
      return { ...state, isTyping: action.payload }
    case 'SET_LOADING':
      return { ...state, isLoading: action.payload }
    case 'CLEAR_MESSAGES':
      return { 
        ...state, 
        messages: [initialState.messages[0]],
        conversationContext: {
          ...state.conversationContext,
          sessionId: generateSessionId(),
          recentProducts: []
        }
      }
    case 'UPDATE_CONVERSATION_CONTEXT':
      return {
        ...state,
        conversationContext: {
          ...state.conversationContext,
          ...action.payload
        }
      }
    case 'START_CHECKOUT':
      return {
        ...state,
        checkoutState: {
          mode: action.payload.mode,
          items: action.payload.items,
          step: 'summary'
        }
      }
    case 'UPDATE_CHECKOUT_STEP':
      if (!state.checkoutState) return state
      return {
        ...state,
        checkoutState: {
          ...state.checkoutState,
          step: action.payload
        }
      }
    case 'SET_SHIPPING_INFO':
      if (!state.checkoutState) return state
      return {
        ...state,
        checkoutState: {
          ...state.checkoutState,
          shippingInfo: action.payload,
          step: 'payment'
        }
      }
    case 'SET_PAYMENT_METHOD':
      if (!state.checkoutState) return state
      return {
        ...state,
        checkoutState: {
          ...state.checkoutState,
          paymentMethod: action.payload,
          step: 'confirmation'
        }
      }
    case 'CANCEL_CHECKOUT':
      return {
        ...state,
        checkoutState: null
      }
    case 'COMPLETE_CHECKOUT':
      return {
        ...state,
        checkoutState: null
      }
    default:
      return state
  }
}

const ChatbotContext = createContext<ChatbotContextType | null>(null)

export const ChatbotProvider = ({ children }: { children: React.ReactNode }) => {
  const [state, dispatch] = useReducer(chatbotReducer, initialState)

  // Load preferences from sessionStorage on mount
  useEffect(() => {
    const loadConversationContext = () => {
      try {
        const savedContext = sessionStorage.getItem('conversationContext')
        if (savedContext) {
          const parsedContext = JSON.parse(savedContext)
          dispatch({
            type: 'UPDATE_CONVERSATION_CONTEXT',
            payload: parsedContext
          })
        }
      } catch (error) {
        console.error('Failed to load conversation context:', error)
      }
    }

    loadConversationContext()
  }, [])

  // Save conversation context to sessionStorage whenever it changes
  useEffect(() => {
    try {
      sessionStorage.setItem('conversationContext', JSON.stringify(state.conversationContext))
    } catch (error) {
      console.error('Failed to save conversation context:', error)
    }
  }, [state.conversationContext])

  const sendMessage = useCallback(async (content: string) => {
    // ì‚¬ìš©ì ë©”ì‹œì§€ ì¶”ê°€
    const userMessage: Message = {
      id: generateMessageId(),
      content,
      sender: 'user',
      timestamp: new Date(),
      type: 'text'
    }
    dispatch({ type: 'ADD_MESSAGE', payload: userMessage })

    // ë¡œë”© ìƒíƒœ ì„¤ì •
    dispatch({ type: 'SET_LOADING', payload: true })
    dispatch({ type: 'SET_TYPING', payload: true })

    try {
      // ì‹¤ì œ API í˜¸ì¶œ
      const response = await sendChatMessage(content, {
        previousMessages: state.messages.slice(-10), // ìµœê·¼ 10ê°œ ë©”ì‹œì§€ë§Œ ì»¨í…ìŠ¤íŠ¸ë¡œ ì „ì†¡
        conversationContext: state.conversationContext
      })

      // API ì‘ë‹µì„ ë©”ì‹œì§€ë¡œ ë³€í™˜
      const botMessage: Message = {
        id: generateMessageId(),
        content: response.message,
        sender: 'bot',
        timestamp: new Date(),
        type: response.type || 'text',
        data: {
          recommendations: response.recommendations,
          faqs: response.faqs,
          products: response.products,
          actions: response.actions
        }
      }
      
      dispatch({ type: 'ADD_MESSAGE', payload: botMessage })
      
    } catch (error) {
      console.error('Failed to send message:', error)
      
      // ì˜¤ë¥˜ ì‹œ í´ë°± ë©”ì‹œì§€
      const errorMessage: Message = {
        id: generateMessageId(),
        content: 'ì£„ì†¡í•©ë‹ˆë‹¤. ì¼ì‹œì ì¸ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”. ğŸ™',
        sender: 'bot',
        timestamp: new Date(),
        type: 'text'
      }
      
      dispatch({ type: 'ADD_MESSAGE', payload: errorMessage })
    } finally {
      dispatch({ type: 'SET_LOADING', payload: false })
      dispatch({ type: 'SET_TYPING', payload: false })
    }
  }, [state.messages, state.conversationContext])

  const cart = useCart()

  const addProductToCart = useCallback(async (productId: string, quantity: number = 1) => {
    try {
      // Check if product already exists in cart
      const existingItem = cart.items.find(item => item.id === productId)
      
      if (existingItem) {
        // Product already in cart - show confirmation message
        const confirmMessage: Message = {
          id: generateMessageId(),
          content: `ì´ë¯¸ ì¥ë°”êµ¬ë‹ˆì— ìˆëŠ” ìƒí’ˆì…ë‹ˆë‹¤. ìˆ˜ëŸ‰ì„ ì¦ê°€ì‹œí‚¬ê¹Œìš”?\ní˜„ì¬ ìˆ˜ëŸ‰: ${existingItem.quantity}ê°œ`,
          sender: 'bot',
          timestamp: new Date(),
          type: 'text',
          data: {
            quickActions: [
              {
                id: `increase_${productId}`,
                label: 'ìˆ˜ëŸ‰ ì¦ê°€',
                type: 'primary',
                payload: { action: 'increase', productId, currentQuantity: existingItem.quantity }
              },
              {
                id: `cancel_${productId}`,
                label: 'ì·¨ì†Œ',
                type: 'secondary'
              }
            ]
          }
        }
        dispatch({ type: 'ADD_MESSAGE', payload: confirmMessage })
        return
      }

      // Fetch product details from the messages to get full product info
      // Look for the product in recent messages
      let productInfo = null
      for (const message of state.messages) {
        if (message.data?.products) {
          productInfo = message.data.products.find((p: any) => p.id === productId)
          if (productInfo) break
        }
      }

      if (!productInfo) {
        // If product not found in messages, show error
        const errorMessage: Message = {
          id: Date.now().toString(),
          content: 'ìƒí’ˆ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
          sender: 'bot',
          timestamp: new Date(),
          type: 'text'
        }
        dispatch({ type: 'ADD_MESSAGE', payload: errorMessage })
        return
      }

      // Convert ProductRecommendation to Product format for CartContext
      const productForCart = {
        id: productInfo.id,
        name: productInfo.name,
        brand: productInfo.brand,
        price: productInfo.price,
        description: productInfo.description,
        notes: productInfo.fragrance || [],
        image: productInfo.image,
        category: productInfo.occasion || 'general'
      }

      // Add to cart
      cart.addItem(productForCart)

      // Update conversation context
      dispatch({
        type: 'UPDATE_CONVERSATION_CONTEXT',
        payload: {
          preferences: {
            ...state.conversationContext.preferences,
            cartHistory: [...state.conversationContext.preferences.cartHistory, productId]
          }
        }
      })

      // Show success message with cart status
      const successMessage: Message = {
        id: Date.now().toString(),
        content: `âœ… ${productInfo.name}ì´(ê°€) ì¥ë°”êµ¬ë‹ˆì— ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!\n\ní˜„ì¬ ì¥ë°”êµ¬ë‹ˆ: ${cart.totalItems + 1}ê°œ ìƒí’ˆ, ì´ ${(cart.totalPrice + productInfo.price).toLocaleString()}ì›`,
        sender: 'bot',
        timestamp: new Date(),
        type: 'text',
        data: {
          quickActions: [
            {
              id: 'view_cart',
              label: 'ì¥ë°”êµ¬ë‹ˆ ë³´ê¸°',
              type: 'primary',
              payload: { action: 'view_cart' }
            },
            {
              id: 'continue_shopping',
              label: 'ì‡¼í•‘ ê³„ì†í•˜ê¸°',
              type: 'secondary'
            }
          ]
        }
      }
      dispatch({ type: 'ADD_MESSAGE', payload: successMessage })

    } catch (error) {
      console.error('Failed to add product to cart:', error)
      
      const errorMessage: Message = {
        id: Date.now().toString(),
        content: 'ì¥ë°”êµ¬ë‹ˆì— ìƒí’ˆì„ ì¶”ê°€í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
        sender: 'bot',
        timestamp: new Date(),
        type: 'text'
      }
      dispatch({ type: 'ADD_MESSAGE', payload: errorMessage })
    }
  }, [cart, state.messages, state.conversationContext, dispatch])

  const startCheckout = useCallback((mode: 'cart' | 'direct', productId?: string) => {
    // Get items based on mode
    let items: CartItem[] = []
    
    if (mode === 'direct' && productId) {
      // For direct purchase, find the product in recent messages
      let productInfo = null
      for (const message of state.messages) {
        if (message.data?.products) {
          productInfo = message.data.products.find((p: any) => p.id === productId)
          if (productInfo) break
        }
      }

      if (!productInfo) {
        const errorMessage: Message = {
          id: Date.now().toString(),
          content: 'ìƒí’ˆ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
          sender: 'bot',
          timestamp: new Date(),
          type: 'text'
        }
        dispatch({ type: 'ADD_MESSAGE', payload: errorMessage })
        return
      }

      // Create temporary cart item for direct purchase
      items = [{
        id: productInfo.id,
        name: productInfo.name,
        brand: productInfo.brand,
        price: productInfo.price,
        description: productInfo.description,
        notes: productInfo.fragrance || [],
        image: productInfo.image,
        category: productInfo.occasion || 'general',
        quantity: 1
      }]
    } else {
      // For cart mode, get items from CartContext
      if (cart.items.length === 0) {
        const emptyMessage: Message = {
          id: Date.now().toString(),
          content: 'ì¥ë°”êµ¬ë‹ˆê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤. ğŸ˜Š\nìƒí’ˆì„ ë¨¼ì € ë‹´ì•„ì£¼ì„¸ìš”.',
          sender: 'bot',
          timestamp: new Date(),
          type: 'text'
        }
        dispatch({ type: 'ADD_MESSAGE', payload: emptyMessage })
        return
      }
      items = cart.items
    }

    dispatch({ 
      type: 'START_CHECKOUT', 
      payload: { mode, items } 
    })

    // Add checkout start message
    const checkoutMessage: Message = {
      id: Date.now().toString(),
      content: 'ê²°ì œë¥¼ ì‹œì‘í•©ë‹ˆë‹¤. ë°°ì†¡ì§€ ì •ë³´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.',
      sender: 'bot',
      timestamp: new Date(),
      type: 'checkout',
      data: {
        checkoutForm: {
          step: 'shipping'
        }
      }
    }
    dispatch({ type: 'ADD_MESSAGE', payload: checkoutMessage })
  }, [cart, state.messages, dispatch])

  const submitShipping = useCallback((info: ShippingInfo) => {
    dispatch({ type: 'SET_SHIPPING_INFO', payload: info })

    // Add payment selection message
    const paymentMessage: Message = {
      id: Date.now().toString(),
      content: 'ë°°ì†¡ì§€ ì •ë³´ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤. ê²°ì œ ìˆ˜ë‹¨ì„ ì„ íƒí•´ì£¼ì„¸ìš”.',
      sender: 'bot',
      timestamp: new Date(),
      type: 'checkout',
      data: {
        checkoutForm: {
          step: 'payment'
        }
      }
    }
    dispatch({ type: 'ADD_MESSAGE', payload: paymentMessage })
  }, [])

  const submitPayment = useCallback(async (method: PaymentMethod) => {
    dispatch({ type: 'SET_PAYMENT_METHOD', payload: method })

    // Show confirmation step with order summary
    const confirmMessage: Message = {
      id: Date.now().toString(),
      content: 'ê²°ì œ ìˆ˜ë‹¨ì´ ì„ íƒë˜ì—ˆìŠµë‹ˆë‹¤. ì£¼ë¬¸ì„ í™•ì¸í•´ì£¼ì„¸ìš”.',
      sender: 'bot',
      timestamp: new Date(),
      type: 'checkout',
      data: {
        checkoutForm: {
          step: 'payment'
        }
      }
    }
    dispatch({ type: 'ADD_MESSAGE', payload: confirmMessage })
  }, [])

  const confirmOrder = useCallback(async () => {
    if (!state.checkoutState || !state.checkoutState.shippingInfo || !state.checkoutState.paymentMethod) {
      const errorMessage: Message = {
        id: Date.now().toString(),
        content: 'ë°°ì†¡ì§€ ì •ë³´ ë˜ëŠ” ê²°ì œ ìˆ˜ë‹¨ì´ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤.',
        sender: 'bot',
        timestamp: new Date(),
        type: 'text'
      }
      dispatch({ type: 'ADD_MESSAGE', payload: errorMessage })
      return
    }

    dispatch({ type: 'SET_LOADING', payload: true })

    try {
      // Import order service dynamically to avoid circular dependencies
      const { orderService } = await import('@/services/order')
      
      // Map payment method type to backend format
      const paymentMethodMap: Record<string, 'CARD' | 'CASH' | 'TRANSFER'> = {
        'card': 'CARD',
        'bank': 'TRANSFER',
        'simple': 'CARD'
      }

      // Prepare order request
      const orderRequest = {
        shippingAddress: `(${state.checkoutState.shippingInfo.postalCode}) ${state.checkoutState.shippingInfo.address} ${state.checkoutState.shippingInfo.addressDetail}`,
        phoneNumber: state.checkoutState.shippingInfo.phone,
        paymentMethod: paymentMethodMap[state.checkoutState.paymentMethod.type] || 'CARD'
      }

      // Call backend API to create order
      const order = await orderService.createOrder(orderRequest)
      
      const orderDate = order.orderDate || new Date().toISOString()
      const estimatedDelivery = new Date(Date.now() + 3 * 24 * 60 * 60 * 1000).toISOString()

      const orderMessage: Message = {
        id: Date.now().toString(),
        content: 'ì£¼ë¬¸ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤! ğŸ‰',
        sender: 'bot',
        timestamp: new Date(),
        type: 'order',
        data: {
          orderConfirmation: {
            orderId: order.orderNumber || order.id,
            orderDate,
            estimatedDelivery,
            items: state.checkoutState.items,
            totalAmount: order.totalAmount,
            shippingInfo: state.checkoutState.shippingInfo,
            paymentMethod: state.checkoutState.paymentMethod,
            status: 'confirmed'
          }
        }
      }

      dispatch({ type: 'ADD_MESSAGE', payload: orderMessage })
      dispatch({ type: 'COMPLETE_CHECKOUT' })

      // Clear cart if checkout was from cart mode
      if (state.checkoutState.mode === 'cart') {
        cart.clearCart()
      }

      // Update conversation context with purchase
      dispatch({
        type: 'UPDATE_CONVERSATION_CONTEXT',
        payload: {
          purchaseHistory: [
            ...state.conversationContext.purchaseHistory,
            ...state.checkoutState.items.map((item: CartItem) => ({
              orderId: order.orderNumber || order.id,
              productId: item.id,
              purchaseDate: new Date(),
              price: item.price
            }))
          ]
        }
      })

    } catch (error: any) {
      console.error('Failed to confirm order:', error)
      
      // Determine error type and message
      let errorContent = 'ì£¼ë¬¸ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
      let retryable = true

      if (error.response) {
        // Backend returned an error
        const status = error.response.status
        if (status === 400) {
          errorContent = 'ì£¼ë¬¸ ì •ë³´ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¤ì‹œ í™•ì¸í•´ì£¼ì„¸ìš”.'
          retryable = false
        } else if (status === 401 || status === 403) {
          errorContent = 'ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.'
          retryable = false
        } else if (status === 404) {
          errorContent = 'ìƒí’ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
          retryable = false
        } else if (status >= 500) {
          errorContent = 'ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.'
        }
      } else if (error.request) {
        // Network error
        errorContent = 'ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”.'
      }
      
      const errorMessage: Message = {
        id: Date.now().toString(),
        content: errorContent,
        sender: 'bot',
        timestamp: new Date(),
        type: 'text',
        data: {
          quickActions: retryable ? [
            {
              id: 'retry_order',
              label: 'ë‹¤ì‹œ ì‹œë„',
              type: 'primary',
              payload: { action: 'retry_order' }
            },
            {
              id: 'cancel_order',
              label: 'ì·¨ì†Œ',
              type: 'secondary',
              payload: { action: 'cancel_checkout' }
            }
          ] : [
            {
              id: 'back_to_cart',
              label: 'ì¥ë°”êµ¬ë‹ˆë¡œ ëŒì•„ê°€ê¸°',
              type: 'secondary',
              payload: { action: 'view_cart' }
            }
          ]
        }
      }
      dispatch({ type: 'ADD_MESSAGE', payload: errorMessage })
    } finally {
      dispatch({ type: 'SET_LOADING', payload: false })
    }
  }, [state.checkoutState, state.conversationContext, cart])

  const cancelCheckout = useCallback(() => {
    dispatch({ type: 'CANCEL_CHECKOUT' })

    const cancelMessage: Message = {
      id: Date.now().toString(),
      content: 'ê²°ì œê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.',
      sender: 'bot',
      timestamp: new Date(),
      type: 'text'
    }
    dispatch({ type: 'ADD_MESSAGE', payload: cancelMessage })
  }, [])

  const toggleChatbot = useCallback(() => {
    dispatch({ type: 'TOGGLE_CHATBOT' })
  }, [])

  const clearMessages = useCallback(() => {
    dispatch({ type: 'CLEAR_MESSAGES' })
    // Clear sessionStorage when clearing messages
    try {
      sessionStorage.removeItem('conversationContext')
    } catch (error) {
      console.error('Failed to clear conversation context:', error)
    }
  }, [])

  // Method to update conversation context preferences
  const updatePreferences = useCallback((preferences: Partial<ConversationContext['preferences']>) => {
    dispatch({
      type: 'UPDATE_CONVERSATION_CONTEXT',
      payload: {
        preferences: {
          ...state.conversationContext.preferences,
          ...preferences
        }
      }
    })
  }, [state.conversationContext.preferences])

  // Method to update user ID when user logs in
  const updateUserId = useCallback((userId?: string) => {
    dispatch({
      type: 'UPDATE_CONVERSATION_CONTEXT',
      payload: { userId }
    })
  }, [])

  // View cart contents
  const viewCart = useCallback(() => {
    if (cart.items.length === 0) {
      const emptyMessage: Message = {
        id: Date.now().toString(),
        content: 'ì¥ë°”êµ¬ë‹ˆê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤. ğŸ˜Š\në§ˆìŒì— ë“œëŠ” í–¥ìˆ˜ë¥¼ ì°¾ì•„ë³¼ê¹Œìš”?',
        sender: 'bot',
        timestamp: new Date(),
        type: 'text'
      }
      dispatch({ type: 'ADD_MESSAGE', payload: emptyMessage })
      return
    }

    // Convert CartItems to ProductRecommendations for display
    const cartProducts = cart.items.map(item => ({
      id: item.id,
      name: item.name,
      brand: item.brand,
      price: item.price,
      image: item.image,
      description: item.description,
      fragrance: item.notes || [],
      notes: {
        top: item.notes?.slice(0, 3) || [],
        middle: [],
        base: []
      }
    }))

    // Create QuickActions for each cart item
    const cartMessage: Message = {
      id: Date.now().toString(),
      content: `ğŸ›’ ì¥ë°”êµ¬ë‹ˆ (${cart.totalItems}ê°œ ìƒí’ˆ, ì´ ${cart.totalPrice.toLocaleString()}ì›)`,
      sender: 'bot',
      timestamp: new Date(),
      type: 'product',
      data: {
        products: cartProducts,
        quickActions: [
          {
            id: 'checkout',
            label: 'ê²°ì œí•˜ê¸°',
            type: 'primary',
            payload: { action: 'checkout' }
          },
          {
            id: 'clear_cart',
            label: 'ì¥ë°”êµ¬ë‹ˆ ë¹„ìš°ê¸°',
            type: 'danger',
            payload: { action: 'clear_cart' }
          },
          {
            id: 'continue_shopping',
            label: 'ì‡¼í•‘ ê³„ì†í•˜ê¸°',
            type: 'secondary',
            payload: { action: 'continue_shopping' }
          }
        ]
      }
    }
    dispatch({ type: 'ADD_MESSAGE', payload: cartMessage })
  }, [cart, dispatch])

  // Handle QuickAction clicks
  const handleQuickAction = useCallback(async (action: QuickActionItem) => {
    if (!action.payload) return

    const { action: actionType, productId } = action.payload

    switch (actionType) {
      case 'increase':
        // Increase quantity in cart
        if (productId) {
          const item = cart.items.find(i => i.id === productId)
          if (item) {
            cart.updateQuantity(productId, item.quantity + 1)
            
            const message: Message = {
              id: Date.now().toString(),
              content: `âœ… ìˆ˜ëŸ‰ì´ ì¦ê°€ë˜ì—ˆìŠµë‹ˆë‹¤. (${item.quantity} â†’ ${item.quantity + 1}ê°œ)`,
              sender: 'bot',
              timestamp: new Date(),
              type: 'text'
            }
            dispatch({ type: 'ADD_MESSAGE', payload: message })
          }
        }
        break

      case 'decrease':
        // Decrease quantity in cart
        if (productId) {
          const item = cart.items.find(i => i.id === productId)
          if (item) {
            if (item.quantity > 1) {
              cart.updateQuantity(productId, item.quantity - 1)
              
              const message: Message = {
                id: Date.now().toString(),
                content: `âœ… ìˆ˜ëŸ‰ì´ ê°ì†Œë˜ì—ˆìŠµë‹ˆë‹¤. (${item.quantity} â†’ ${item.quantity - 1}ê°œ)`,
                sender: 'bot',
                timestamp: new Date(),
                type: 'text'
              }
              dispatch({ type: 'ADD_MESSAGE', payload: message })
            } else {
              // Quantity is 1, will be removed
              cart.updateQuantity(productId, 0)
              
              const message: Message = {
                id: Date.now().toString(),
                content: `âœ… ìƒí’ˆì´ ì¥ë°”êµ¬ë‹ˆì—ì„œ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤.`,
                sender: 'bot',
                timestamp: new Date(),
                type: 'text'
              }
              dispatch({ type: 'ADD_MESSAGE', payload: message })
            }
          }
        }
        break

      case 'remove':
        // Remove item from cart
        if (productId) {
          const item = cart.items.find(i => i.id === productId)
          if (item) {
            cart.removeItem(productId)
            
            const message: Message = {
              id: Date.now().toString(),
              content: `âœ… ${item.name}ì´(ê°€) ì¥ë°”êµ¬ë‹ˆì—ì„œ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤.`,
              sender: 'bot',
              timestamp: new Date(),
              type: 'text'
            }
            dispatch({ type: 'ADD_MESSAGE', payload: message })
          }
        }
        break

      case 'view_cart':
        // Show cart contents
        viewCart()
        break

      case 'clear_cart':
        // Clear all items from cart
        cart.clearCart()
        const clearMessage: Message = {
          id: Date.now().toString(),
          content: 'âœ… ì¥ë°”êµ¬ë‹ˆê°€ ë¹„ì›Œì¡ŒìŠµë‹ˆë‹¤.',
          sender: 'bot',
          timestamp: new Date(),
          type: 'text'
        }
        dispatch({ type: 'ADD_MESSAGE', payload: clearMessage })
        break

      case 'checkout':
        // Start checkout process
        startCheckout('cart')
        break

      case 'continue_shopping':
        // Just acknowledge
        const continueMessage: Message = {
          id: Date.now().toString(),
          content: 'ì–´ë–¤ í–¥ìˆ˜ë¥¼ ì°¾ê³  ê³„ì‹ ê°€ìš”? ğŸ˜Š',
          sender: 'bot',
          timestamp: new Date(),
          type: 'text'
        }
        dispatch({ type: 'ADD_MESSAGE', payload: continueMessage })
        break

      case 'retry_order':
        // Retry order confirmation
        await confirmOrder()
        break

      case 'cancel_checkout':
        // Cancel checkout
        cancelCheckout()
        break

      default:
        break
    }
  }, [cart, dispatch, viewCart, startCheckout])

  const value: ChatbotContextType = {
    state,
    sendMessage,
    addProductToCart,
    viewCart,
    startCheckout,
    submitShipping,
    submitPayment,
    confirmOrder,
    cancelCheckout,
    toggleChatbot,
    clearMessages,
    updatePreferences,
    updateUserId,
    handleQuickAction
  }

  return <ChatbotContext.Provider value={value}>{children}</ChatbotContext.Provider>
}

export const useChatbot = () => {
  const context = useContext(ChatbotContext)
  if (!context) {
    throw new Error('useChatbot must be used within a ChatbotProvider')
  }
  return context
}

